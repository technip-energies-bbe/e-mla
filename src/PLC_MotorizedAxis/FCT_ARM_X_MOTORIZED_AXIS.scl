FUNCTION_BLOCK "FCT_SLEWING_AXIS_DRIVE"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      ENABLE_SLEWING_DRIVE : Bool;
      MOTION_SLEWING : Bool;   // ORDRE DE MARCHE (1 SEUL ORDRE = MAV)
      SP_SLEWING_DRIVE : Int;   // SP SLEWING DEPUIS CARTE ANA (-13824=DROITE;+13824=GAUCHE)
   END_VAR

   VAR_OUTPUT 
      CMD_DRIVE_SLEWING : Int;   // PILOTAGE DRIVE SLEWING (-50=DROITE ; +50=GAUCHE)
      ERREUR_DRIVE_SLEWING : Int;   // ERREUR DU DRIVE (10=Pas de Enable ou 11=Pas d'ordre de marche)
   END_VAR


BEGIN
	//Initialisation
	#CMD_DRIVE_SLEWING := 0;
	#ERREUR_DRIVE_SLEWING := 0;
	
	
	// Drive Setpoint Management
	IF #ENABLE_SLEWING_DRIVE = TRUE THEN
	    #CMD_DRIVE_SLEWING := #SP_SLEWING_DRIVE;
	ELSE
	    #CMD_DRIVE_SLEWING := 0;
	END_IF;
	
	//Error management
	IF #ENABLE_SLEWING_DRIVE=FALSE AND #MOTION_SLEWING = TRUE THEN
	    #ERREUR_DRIVE_SLEWING := 10;
	    ELSIF #ENABLE_SLEWING_DRIVE = TRUE AND #MOTION_SLEWING = FALSE AND #CMD_DRIVE_SLEWING <> 0 THEN
	        #ERREUR_DRIVE_SLEWING := 11;
	    ELSE
	        #ERREUR_DRIVE_SLEWING := 0;
	    END_IF;
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FCT_INBOARD_AXIS_DRIVE"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      ENABLE_INBOARD_DRIVE : Bool;
      MOTION_INBOARD : Bool;   // ORDRE DE MARCHE ( 1SEUL ORDRE MAV)
      SP_INBOARD_DRIVE : Int;   // SP INBOARD DEPUIS CARTE ANA (-13824=FWD;13824=BACK)
   END_VAR

   VAR_OUTPUT 
      CMD_DRIVE_INBOARD : Int;   // PILOTAGE DRIVE INBOARD (-50=FWD;+50=BCK)
      ERREUR_DRIVE_INBOARD : Int;   // ERREUR DU DRIVE (20=Pas d'Enable ou 21=Pas d'ordre de marche)
   END_VAR


BEGIN
	//Initialisation
	#CMD_DRIVE_INBOARD := 0;
	#ERREUR_DRIVE_INBOARD := 0;
	
	
	// Drive Setpoint Management
	IF #ENABLE_INBOARD_DRIVE = TRUE THEN
	    #CMD_DRIVE_INBOARD  := #SP_INBOARD_DRIVE;
	ELSE
	    #CMD_DRIVE_INBOARD  := 0;
	END_IF;
	
	//Error management
	IF #ENABLE_INBOARD_DRIVE = FALSE AND #MOTION_INBOARD = TRUE THEN
	    #ERREUR_DRIVE_INBOARD := 20;
	ELSIF #ENABLE_INBOARD_DRIVE = TRUE AND #MOTION_INBOARD = FALSE AND #CMD_DRIVE_INBOARD  <> 0 THEN
	    #ERREUR_DRIVE_INBOARD := 21;
	ELSE
	    #ERREUR_DRIVE_INBOARD := 0;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FCT_OUTBOARD_AXIS_DRIVE"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      ENABLE_OUTBOARD_DRIVE : Bool;
      MOTION_OUTBOARD : Bool;   // ORDRE DE MARCHE (1 SEUL ORDRE = MAV)
      SP_OUTBOARD_DRIVE : Int;   // SP OUTBORAD DEPUIS CARTE ANA (-13824=IN;+13824=OUT)
   END_VAR

   VAR_OUTPUT 
      CMD_DRIVE_OUTBOARD : Int;   // PILOTAGE DRIVE OUTBOARD (-50=IN;+50=OUT)
      ERREUR_DRIVE_OUTBOARD : Int;   // ERREUR DU DRIVE (30=Pas d'Enable ou 31=Pas d'ordre de marche)
   END_VAR


BEGIN
	//Initialisation
	#CMD_DRIVE_OUTBOARD := 0;
	#ERREUR_DRIVE_OUTBOARD := 0;
	
	
	// Drive Setpoint Management
	IF #ENABLE_OUTBOARD_DRIVE = TRUE THEN
	    #CMD_DRIVE_OUTBOARD := #SP_OUTBOARD_DRIVE;
	ELSE
	    #CMD_DRIVE_OUTBOARD := 0;
	END_IF;
	
	//Error management
	IF #ENABLE_OUTBOARD_DRIVE = FALSE AND #MOTION_OUTBOARD = TRUE THEN
	    #ERREUR_DRIVE_OUTBOARD := 30;
	ELSIF #ENABLE_OUTBOARD_DRIVE = TRUE AND #MOTION_OUTBOARD = FALSE AND #CMD_DRIVE_OUTBOARD <> 0 THEN
	    #ERREUR_DRIVE_OUTBOARD := 31;
	ELSE
	    #ERREUR_DRIVE_OUTBOARD := 0;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FCT_ST80_AXIS_DRIVE"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      ENABLE_ST80_DRIVE : Bool;
      MOTION_ST80 : Bool;   // ORDRE DE MARCHE (1 SEUL ORDRE = MAV
      SP_ST80_DRIVE : Int;   // SP ST80 DEPUIS CARTE ANA (-13824=DROITE;+13824=GAUCHE)
   END_VAR

   VAR_OUTPUT 
      CMD_DRIVE_ST80 : Int;   // PILOTAGE DRIVE ST80 (-50=DROITE; +50=GAUCHE)
      ERREUR_DRIVE_ST80 : Int;   // ERREUR DU DRIVE (40=Pas d'Enable ou 41=Pas d'ordre de marche)
   END_VAR


BEGIN
	//Initialisation
	#CMD_DRIVE_ST80 := 0;
	#ERREUR_DRIVE_ST80 := 0;
	
	
	// Drive Setpoint Management
	IF #ENABLE_ST80_DRIVE = TRUE THEN
	    #CMD_DRIVE_ST80 := #SP_ST80_DRIVE;
	ELSE
	    #CMD_DRIVE_ST80 := 0;
	END_IF;
	
	//Error management
	IF #ENABLE_ST80_DRIVE = FALSE AND #MOTION_ST80 = TRUE THEN
	    #ERREUR_DRIVE_ST80 := 40;
	ELSIF #ENABLE_ST80_DRIVE = TRUE AND #MOTION_ST80 = FALSE AND #CMD_DRIVE_ST80 <> 0 THEN
	    #ERREUR_DRIVE_ST80 := 41;
	ELSE
	    #ERREUR_DRIVE_ST80 := 0;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FCT_QCDC_AXIS_DRIVE"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      ENABLE_QCDC_DRIVE : Bool;
      MOTION_QCDC : Bool;   // ORDRE DE MARCHE (1 SEUL ORDRE = MAV)
      SP_QCDC_DRIVE : Int;   // SP QCDC DEPUIS CARTE ANA (-13824=DROITE; +13824=GAUCHE)
   END_VAR

   VAR_OUTPUT 
      CMD_DRIVE_QCDC : Int;   // PILOTAGE DRIVE QCDC (-50=DROITE; +50=GAUCHE)
      ERREUR_DRIVE_QCDC : Int;   // ERREUR DU DRIVE (50=Pas d'Enable ou 51=Pas d'ordre de marche)
   END_VAR


BEGIN
	//Initialisation
	#CMD_DRIVE_QCDC := 0;
	#ERREUR_DRIVE_QCDC := 0;
	
	
	// Drive Setpoint Management
	IF #ENABLE_QCDC_DRIVE = TRUE THEN
	    #CMD_DRIVE_QCDC := #SP_QCDC_DRIVE;
	ELSE
	    #CMD_DRIVE_QCDC := 0;
	END_IF;
	
	//Error management
	IF #ENABLE_QCDC_DRIVE = FALSE AND #MOTION_QCDC = TRUE THEN
	    #ERREUR_DRIVE_QCDC := 50;
	ELSIF #ENABLE_QCDC_DRIVE = TRUE AND #MOTION_QCDC = FALSE AND #CMD_DRIVE_QCDC <> 0 THEN
	    #ERREUR_DRIVE_QCDC := 51;
	ELSE
	    #ERREUR_DRIVE_QCDC := 0;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FCT_ARM_X_MOTORIZED_AXIS"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      ENABLE_SLEWING_DRIVE : Bool;
      MOTION_SLEWING : Bool;
      SP_SLEWING_DRIVE : Int;
      ENABLE_INBOARD_DRIVE : Bool;
      MOTION_INBOARD : Bool;
      SP_INBOARD_DRIVE : Int;
      ENABLE_OUTBOARD_DRIVE : Bool;
      MOTION_OUTBOARD : Bool;
      SP_OUTBOARD_DRIVE : Int;
      ENABLE_ST80_DRIVE : Bool;
      MOTION_ST80 : Bool;
      SP_ST80_DRIVE : Int;
      ENABLE_QCDC_DRIVE : Bool;
      MOTION_QCDC : Bool;
      SP_QCDC_DRIVE : Int;
   END_VAR

   VAR_OUTPUT 
      CMD_DRIVE_SLEWING : Int;
      CMD_DRIVE_INBOARD : Int;
      CMD_DRIVE_OUTBOARD : Int;
      CMD_DRIVE_ST80 : Int;
      CMD_DRIVE_QCDC : Int;
      ERREUR_DRIVE : Int;   // ERREUR DES FCTS INTERNE (0=No error, 1=Slewing, 2=Inboard, 3=Outboard, 4=ST80, 5=QCDC)
   END_VAR

   VAR 
      FCT_SLEWING_AXIS_DRIVE_Instance : "FCT_SLEWING_AXIS_DRIVE";
      FCT_INBOARD_AXIS_DRIVE_Instance : "FCT_INBOARD_AXIS_DRIVE";
      FCT_OUTBOARD_AXIS_DRIVE_Instance : "FCT_OUTBOARD_AXIS_DRIVE";
      FCT_ST80_AXIS_DRIVE_Instance : "FCT_ST80_AXIS_DRIVE";
      FCT_QCDC_AXIS_DRIVE_Instance : "FCT_QCDC_AXIS_DRIVE";
   END_VAR

   VAR_TEMP 
      ERREUR_DRIVE_SLEWING : Int;
      ERREUR_DRIVE_INBOARD : Int;
      ERREUR_DRIVE_OUTBOARD : Int;
      ERREUR_DRIVE_ST80 : Int;
      ERREUR_DRIVE_QCDC : Int;
   END_VAR


BEGIN
	// Call sub-routine Slewing Axis
	#FCT_SLEWING_AXIS_DRIVE_Instance(ENABLE_SLEWING_DRIVE:=#ENABLE_SLEWING_DRIVE,
	                                 MOTION_SLEWING:=#MOTION_SLEWING,
	                                 SP_SLEWING_DRIVE:=#SP_SLEWING_DRIVE,
	                                 CMD_DRIVE_SLEWING=>#CMD_DRIVE_SLEWING,
	                                 ERREUR_DRIVE_SLEWING=>#ERREUR_DRIVE_SLEWING);
	
	// Call sub-routine Inboard Axis
	#FCT_INBOARD_AXIS_DRIVE_Instance(ENABLE_INBOARD_DRIVE:=#ENABLE_INBOARD_DRIVE,
	                                 MOTION_INBOARD:=#MOTION_INBOARD,
	                                 SP_INBOARD_DRIVE:=#SP_INBOARD_DRIVE,
	                                 CMD_DRIVE_INBOARD=>#CMD_DRIVE_INBOARD,
	                                 ERREUR_DRIVE_INBOARD=>#ERREUR_DRIVE_INBOARD);
	
	// Call sub-routine Outboard Axis
	#FCT_OUTBOARD_AXIS_DRIVE_Instance(ENABLE_OUTBOARD_DRIVE:=#ENABLE_OUTBOARD_DRIVE,
	                                  MOTION_OUTBOARD:=#MOTION_OUTBOARD,
	                                  SP_OUTBOARD_DRIVE:=#SP_OUTBOARD_DRIVE,
	                                  CMD_DRIVE_OUTBOARD=>#CMD_DRIVE_OUTBOARD,
	                                  ERREUR_DRIVE_OUTBOARD=>#ERREUR_DRIVE_OUTBOARD);
	
	
	// Call sub-routine ST80 Axis
	#FCT_ST80_AXIS_DRIVE_Instance(ENABLE_ST80_DRIVE:=#ENABLE_ST80_DRIVE,
	                              MOTION_ST80:=#MOTION_ST80,
	                              SP_ST80_DRIVE:=#SP_ST80_DRIVE,
	                              CMD_DRIVE_ST80=>#CMD_DRIVE_ST80,
	                              ERREUR_DRIVE_ST80=>#ERREUR_DRIVE_ST80);
	
	
	// Call sub-routine QCDC Axis
	#FCT_QCDC_AXIS_DRIVE_Instance(ENABLE_QCDC_DRIVE:=#ENABLE_QCDC_DRIVE,
	                              MOTION_QCDC:=#MOTION_QCDC,
	                              SP_QCDC_DRIVE:=#SP_QCDC_DRIVE,
	                              CMD_DRIVE_QCDC=>#CMD_DRIVE_QCDC,
	                              ERREUR_DRIVE_QCDC=>#ERREUR_DRIVE_QCDC);
	
	
	
	
	//Error management
	IF #ERREUR_DRIVE_SLEWING <>0 THEN
	    #ERREUR_DRIVE := #ERREUR_DRIVE_SLEWING ;
	ELSIF #ERREUR_DRIVE_INBOARD <> 0 THEN
	    #ERREUR_DRIVE := #ERREUR_DRIVE_INBOARD;
	ELSIF #ERREUR_DRIVE_OUTBOARD <> 0 THEN
	    #ERREUR_DRIVE := #ERREUR_DRIVE_OUTBOARD;
	ELSIF #ERREUR_DRIVE_ST80 <> 0 THEN
	    #ERREUR_DRIVE := #ERREUR_DRIVE_ST80;
	ELSIF #ERREUR_DRIVE_QCDC <> 0 THEN
	    #ERREUR_DRIVE := #ERREUR_DRIVE_QCDC;
	ELSE
	    #ERREUR_DRIVE := 0;
	END_IF;
END_FUNCTION_BLOCK

